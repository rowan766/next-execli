# React 面试知识点复习文档

## 1. useEffect 清理函数的执行时机

### 核心问题：useEffect 的清理函数什么时候执行？

**答案：三种情况下会执行清理函数**

### 1.1 组件卸载时
```javascript
useEffect(() => {
  const timer = setInterval(() => console.log('timer'), 1000);
  
  return () => {
    clearInterval(timer); // 组件卸载时清理定时器
  };
}, []);
```

### 1.2 依赖项发生变化时
```javascript
useEffect(() => {
  console.log('effect 执行，userId:', userId);
  const unsubscribe = subscribeToUser(userId);
  
  return () => {
    console.log('清理上一次订阅');
    unsubscribe(); // 先清理上次订阅，再建立新订阅
  };
}, [userId]); // userId 变化时会触发清理
```

### 1.3 下一次 effect 执行前
执行顺序：**清理函数 → 新的 effect**

```javascript
// 点击按钮时的输出顺序：
// 1. effect 执行，count: 0
// 2. 清理函数执行，count: 0  // 先清理
// 1. effect 执行，count: 1     // 再执行新的
```

### 关键记忆点：
- 清理函数不仅在组件卸载时执行
- 依赖变化时也会执行清理函数
- 目的：防止内存泄漏和副作用冲突

---

## 2. 如何避免无限循环的 useEffect

### 2.1 缺少依赖项
```javascript
// ❌ 错误
useEffect(() => {
  fetchUser(userId).then(setUser); // 使用了 userId 但没在依赖中声明
}, []); // 空依赖数组

// ✅ 正确
useEffect(() => {
  fetchUser(userId).then(setUser);
}, [userId]); // 正确添加 userId 依赖
```

### 2.2 依赖项包含对象或数组
```javascript
// ❌ 错误：对象引用每次都不同
const config = { apiKey: 'xxx', timeout: 5000 }; // 每次渲染都是新对象
useEffect(() => {
  fetchData(config).then(setData);
}, [config]); // config 每次都是新的引用，导致无限循环

// ✅ 解决方案1：将对象移到 effect 内部
useEffect(() => {
  const config = { apiKey: 'xxx', timeout: 5000 };
  fetchData(config).then(setData);
}, []); // 不依赖外部对象

// ✅ 解决方案2：使用 useMemo 稳定引用
const config = useMemo(() => ({
  apiKey: 'xxx',
  timeout: 5000
}), []); // 稳定的对象引用

// ✅ 解决方案3：只依赖对象的具体属性
useEffect(() => {
  fetchData(config).then(setData);
}, [config.apiKey, config.timeout]); // 依赖具体值而不是对象
```

### 2.3 在 effect 中更新依赖的状态
```javascript
// ❌ 错误
useEffect(() => {
  setCount(count + 1); // 更新了依赖的状态
}, [count]); // count 变化会触发 effect，形成循环

// ✅ 解决方案1：使用函数式更新
useEffect(() => {
  setCount(prev => prev + 1); // 不依赖外部的 count 值
}, []); // 移除 count 依赖

// ✅ 解决方案2：添加条件判断
useEffect(() => {
  if (count < 10) { // 添加条件避免无限更新
    setCount(count + 1);
  }
}, [count]);
```

### 2.4 函数依赖导致的循环
```javascript
// ❌ 错误：函数每次渲染都是新的
const fetchData = async () => { // 每次渲染都是新函数
  const result = await api.getData(userId);
  setData(result);
};

useEffect(() => {
  fetchData();
}, [fetchData]); // fetchData 每次都是新的引用

// ✅ 解决方案1：使用 useCallback 稳定函数引用
const fetchData = useCallback(async () => {
  const result = await api.getData(userId);
  setData(result);
}, [userId]); // 只有 userId 变化时函数才会重新创建

// ✅ 解决方案2：将函数移到 effect 内部
useEffect(() => {
  const fetchData = async () => {
    const result = await api.getData(userId);
    setData(result);
  };
  
  fetchData();
}, [userId]); // 只依赖 userId
```

### 核心原则：
1. **正确添加依赖项**：所有在 effect 中使用的变量都要加入依赖数组
2. **稳定对象引用**：使用 useMemo、useCallback 或将对象移到 effect 内部
3. **避免在 effect 中更新依赖的状态**：使用函数式更新或添加条件判断
4. **函数依赖要稳定**：使用 useCallback 或移到 effect 内部

---

## 3. Next.js 13+ Server/Client Component

### 3.1 判断组件类型的依据

#### App Router 默认规则：
- **`app` 目录**：组件默认是 Server Component
- **其他目录**（`components`、`hooks` 等）：组件默认是 Client Component

```javascript
// app/page.tsx - Server Component
export default function HomePage() {
  // ❌ 不能使用 useState、useEffect 等 Hook
  // ❌ 不能使用浏览器 API
  // ✅ 可以直接访问数据库、文件系统
}

// components/MyComponent.tsx - Client Component
import { useState } from 'react' // ✅ 可以使用！
export default function MyComponent() {
  const [count, setCount] = useState(0) // ✅ 完全没问题
}
```

### 3.2 'use client' 指令的作用

`'use client'` 是**边界标记**，可以将 Server Component 转换为 Client Component：

```javascript
'use client' // 这是边界标记，不是普通注释

import { useState } from 'react'

export default function MyComponent() {
  const [count, setCount] = useState(0) // 现在可以使用 Hook 了
  return <div>{count}</div>
}
```

#### 注意事项：
- **传染性**：标记了 `'use client'` 的组件，其导入的所有组件也会变成客户端组件
- **性能影响**：过度使用会增加客户端 JS bundle 大小
- **精确使用**：只在需要交互的组件上使用

---

## 4. 多接口调用的优雅处理方式

### 4.1 问题：多个接口都写在一个 useEffect 不够优雅

```javascript
// ❌ 不优雅的写法
useEffect(() => {
  const fetchAllData = async () => {
    setLoading(true);
    try {
      const [userData, postsData, followersData] = await Promise.all([
        api.getUser(userId),
        api.getUserPosts(userId),
        api.getUserFollowers(userId)
      ]);
      // 设置各种状态...
    } catch (error) {
      // 错误处理...
    } finally {
      setLoading(false);
    }
  };
  fetchAllData();
}, [userId]); // 代码太长，难以维护
```

### 4.2 解决方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| 多个 useEffect | 关注点分离，逻辑清晰 | 代码冗余，错误处理重复 | 简单项目 |
| 自定义 Hook | 可复用，逻辑封装好 | 需要更多代码组织 | 中等项目 |
| TanStack Query | 功能强大，开箱即用 | 学习成本，依赖外部库 | 复杂项目 |

### 4.3 推荐方案：自定义 Hook
```javascript
// hooks/useUserData.js
function useUserData(userId) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      try {
        const userData = await api.getUser(userId);
        setUser(userData);
        setError(null);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchUser();
  }, [userId]);
  
  return { user, loading, error };
}

// 在组件中使用
function UserDashboard({ userId }) {
  const { user, loading: userLoading } = useUserData(userId);
  const { posts, loading: postsLoading } = useUserPosts(userId);
  const { followers } = useUserFollowers(userId);
  
  if (userLoading) return <div>加载用户信息...</div>;
  
  return (
    <div>
      <UserProfile user={user} />
      <UserPosts posts={posts} loading={postsLoading} />
      <UserFollowers followers={followers} />
    </div>
  );
}
```

---

## 5. TanStack Query (React Query) 详解

### 5.1 什么是 TanStack Query？

TanStack Query 是一个**专门用于数据获取和状态管理的库**，解决传统 useEffect + fetch 方式的痛点。

### 5.2 核心功能

#### 自动缓存
```javascript
// 第一次访问
const { data: user } = useQuery({
  queryKey: ['user', '123'],
  queryFn: () => api.getUser('123') // 发起网络请求
});

// 再次访问同一用户
const { data: user } = useQuery({
  queryKey: ['user', '123'], // 相同的 key
  queryFn: () => api.getUser('123') // 不会发起请求，直接从缓存返回！
});
```

#### 自动重试和背景更新
```javascript
const { data, error } = useQuery({
  queryKey: ['posts'],
  queryFn: fetchPosts,
  retry: 3, // 失败时自动重试 3 次
  staleTime: 5 * 60 * 1000, // 5分钟内认为数据是新鲜的
  refetchOnWindowFocus: true // 窗口重新获得焦点时自动更新
});
```

### 5.3 数据同步原理

**核心原理：全局缓存 + 发布订阅模式**

```javascript
// 简化版原理
const globalCache = {
  'user-123': {
    data: { id: 123, name: '张三' },
    status: 'success',
    updatedAt: '2024-01-01T10:00:00Z'
  }
};

// 组件A 和组件B 使用相同的 queryKey
const { data } = useQuery({
  queryKey: ['user', 123], // 转换成 'user-123' 作为缓存键
  queryFn: () => api.getUser(123)
});
// 两个组件会自动共享同一份数据！
```

#### 工作流程：
1. **第一次请求**：检查缓存 → 发起请求 → 订阅更新 → 更新缓存 → 通知组件
2. **第二次请求**：检查缓存 → 直接返回 → 订阅更新
3. **数据更新**：更新缓存 → 通知所有订阅者重新渲染

### 5.4 数据变更后的更新策略

**重要：TanStack Query 不会自动知道数据变了，需要主动告诉它！**

#### 方案1：手动触发重新获取
```javascript
const { data: posts, refetch } = useQuery({
  queryKey: ['posts'],
  queryFn: () => api.getPosts()
});

const { mutate: createPost } = useMutation({
  mutationFn: (newPost) => api.createPost(newPost),
  onSuccess: () => {
    refetch(); // 新增成功后，重新获取列表数据
  }
});
```

#### 方案2：使用 invalidateQueries 让缓存失效
```javascript
const { mutate: createPost } = useMutation({
  mutationFn: (newPost) => api.createPost(newPost),
  onSuccess: () => {
    // 让所有相关的查询失效，触发重新获取
    queryClient.invalidateQueries({ queryKey: ['posts'] });
  }
});
```

#### 方案3：直接更新缓存数据
```javascript
const { mutate: createPost } = useMutation({
  mutationFn: (newPost) => api.createPost(newPost),
  onSuccess: (createdPost) => {
    // 直接更新缓存中的列表数据
    queryClient.setQueryData(['posts'], (oldPosts) => [
      ...oldPosts,
      createdPost // 服务器返回的真实数据
    ]);
  }
});
```

#### 方案4：乐观更新（立即更新UI）
```javascript
const { mutate: createPost } = useMutation({
  mutationFn: (newPost) => api.createPost(newPost),
  onMutate: async (newPost) => {
    // 乐观更新：立即添加新文章到列表
    queryClient.setQueryData(['posts'], (old) => [
      ...old,
      { ...newPost, id: Date.now() } // 临时ID
    ]);
  },
  onError: (err, newPost, context) => {
    // 出错时回滚
    queryClient.setQueryData(['posts'], context.previousPosts);
  },
  onSettled: () => {
    // 无论成功失败，都重新获取确保数据一致性
    queryClient.invalidateQueries({ queryKey: ['posts'] });
  }
});
```

### 5.5 基本使用步骤

#### 1. 安装
```bash
npm install @tanstack/react-query
```

#### 2. 设置 QueryClient
```javascript
// app/layout.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

export default function App({ children }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
}
```

#### 3. 在组件中使用
```javascript
import { useQuery } from '@tanstack/react-query';

function PostsList() {
  const { 
    data: posts, 
    isLoading, 
    error,
    refetch 
  } = useQuery({
    queryKey: ['posts'],
    queryFn: async () => {
      const response = await fetch('/api/posts');
      return response.json();
    }
  });
  
  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>加载失败 <button onClick={refetch}>重试</button></div>;
  
  return (
    <div>
      {posts?.map(post => (
        <div key={post.id}>{post.title}</div>
      ))}
    </div>
  );
}
```

---

## 6. 关键记忆点总结

### useEffect 相关
- **清理函数执行时机**：组件卸载 + 依赖变化 + 下次 effect 执行前
- **空依赖数组**：挂载时执行主逻辑，卸载时执行清理函数
- **避免无限循环**：正确添加依赖、稳定对象引用、避免更新依赖状态

### Next.js 组件类型
- **app 目录**：默认 Server Component，需要 `'use client'` 才能用 Hook
- **其他目录**：默认 Client Component，可以直接使用 Hook

### 数据获取最佳实践
- **简单项目**：多个 useEffect 分离关注点
- **中等项目**：自定义 Hook 封装逻辑
- **复杂项目**：TanStack Query 全面管理

### TanStack Query 核心
- **自动缓存**：相同 queryKey 共享数据
- **不会自动更新**：需要主动使用 refetch、invalidate、setQueryData
- **更新策略**：手动重新获取、缓存失效、直接更新、乐观更新